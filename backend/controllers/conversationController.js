const Conversation = require('../models/conversationModel');
const User = require('../models/userModel');
const mongoose = require('mongoose');
const { processYouTubeUrl, createMediaResponse, validateMediaFile } = require('../utils/mediaHelper');
const googleDrive = require('../config/googleDrive');
const Post = require('../models/postModel'); // –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç Post
const { sendNewMessageNotification } = require('../utils/emailService');
// –£–¥–∞–ª—è–µ–º –∏–º–ø–æ—Ä—Ç onlineUsers –∏ io
// const { onlineUsers, io } = require('../index');

// @desc    –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –¥–∏–∞–ª–æ–≥–æ–≤ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
// @route   GET /api/conversations
// @access  Private
exports.getConversations = async (req, res) => {
  try {
    const userId = req.user.id;

    const conversations = await Conversation.find({ participants: userId })
      .populate({
        path: 'participants',
        select: 'username avatar email isOnline lastActive',
        match: { _id: { $ne: userId } } // –ü–æ–ª—É—á–∞–µ–º —Ç–æ–ª—å–∫–æ –¥—Ä—É–≥–æ–≥–æ —É—á–∞—Å—Ç–Ω–∏–∫–∞, –∞ –Ω–µ —Å–µ–±—è
      })
      .sort({ lastMessageAt: -1 })
      .lean();

    // –ú–æ–¥–∏—Ñ–∏—Ü–∏—Ä—É–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç, —á—Ç–æ–±—ã participants –±—ã–ª –æ–±—ä–µ–∫—Ç–æ–º –¥—Ä—É–≥–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è, –∞ –Ω–µ –º–∞—Å—Å–∏–≤–æ–º
    const formattedConversations = conversations.map(conv => {
      // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ –µ—Å—Ç—å —É—á–∞—Å—Ç–Ω–∏–∫–∏ –∏ —Å–æ–æ–±—â–µ–Ω–∏—è (–¥–ª—è —Å–ª—É—á–∞–µ–≤ –Ω–æ–≤—ã—Ö –ø—É—Å—Ç—ã—Ö –¥–∏–∞–ª–æ–≥–æ–≤)
      const otherParticipant = conv.participants.find(p => p._id.toString() !== userId);
      // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
      const lastMessage = conv.messages && conv.messages.length > 0 
        ? conv.messages.sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt))[0] 
        : null;
      return {
        _id: conv._id,
        participant: otherParticipant,
        lastMessage: lastMessage,
        lastMessageAt: conv.lastMessageAt,
        createdAt: conv.createdAt,
        updatedAt: conv.updatedAt
      };
    });

    res.status(200).json({
      message: 'Conversations fetched successfully',
      conversations: formattedConversations
    });

  } catch (error) {
    console.error('Error fetching conversations:', error);
    res.status(500).json({ message: 'Server error while fetching conversations.', error: error.message });
  }
};

// @desc    –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏–π –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –¥–∏–∞–ª–æ–≥–∞
// @route   GET /api/conversations/:conversationId/messages
// @access  Private
exports.getMessagesForConversation = async (req, res) => {
  try {
    const { conversationId } = req.params;
    const userId = req.user.id;
    const limit = parseInt(req.query.limit) || 20; // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Å–æ–æ–±—â–µ–Ω–∏–π –Ω–∞ –∑–∞–ø—Ä–æ—Å
    const offset = parseInt(req.query.offset) || 0; // –°–º–µ—â–µ–Ω–∏–µ –æ—Ç –∫–æ–Ω—Ü–∞

    const conversation = await Conversation.findOne({
      _id: conversationId,
      participants: userId // –£–±–µ–¥–∏–º—Å—è, —á—Ç–æ —Ç–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å —è–≤–ª—è–µ—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–æ–º –¥–∏–∞–ª–æ–≥–∞
    })
    .populate({
      path: 'messages.sender',
      select: 'username avatar' // –î–∞–Ω–Ω—ã–µ –æ—Ç–ø—Ä–∞–≤–∏—Ç–µ–ª—è –¥–ª—è –∫–∞–∂–¥–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è
    })
    .populate({
      path: 'messages.sharedPost.post',
      model: 'Post',
      populate: [
        {
          path: 'author',
          model: 'User',
          select: 'username avatar'
        },
        {
          path: 'comments',
          populate: {
            path: 'user',
            model: 'User',
            select: 'username avatar'
          }
        }
      ]
    })
    .select('messages participants'); // –í—ã–±–∏—Ä–∞–µ–º —Ç–æ–ª—å–∫–æ —Å–æ–æ–±—â–µ–Ω–∏—è –∏ —É—á–∞—Å—Ç–Ω–∏–∫–æ–≤

    if (!conversation) {
      return res.status(404).json({ message: 'Conversation not found or you do not have access.' });
    }

    // –°–æ—Ä—Ç–∏—Ä—É–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ –¥–∞—Ç–µ (—Å—Ç–∞—Ä—ã–µ -> –Ω–æ–≤—ã–µ)
    const sortedMessages = conversation.messages.sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt));
    
    const totalMessages = sortedMessages.length;

    // –î–ª—è offset=0 –±–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ limit —Å–æ–æ–±—â–µ–Ω–∏–π
    // –î–ª—è offset>0 –±–µ—Ä–µ–º —Å–æ–æ–±—â–µ–Ω–∏—è —Å –∫–æ–Ω—Ü–∞, –ø—Ä–æ–ø—É—Å–∫–∞—è offset —Å–æ–æ–±—â–µ–Ω–∏–π
    const endIndex = totalMessages - offset;
    const startIndex = Math.max(0, endIndex - limit);

    const paginatedMessages = sortedMessages.slice(startIndex, endIndex);

    res.status(200).json({
      message: 'Conversation messages fetched successfully',
      conversationId,
      messages: paginatedMessages,
      totalCount: totalMessages,
      limit,
      offset
    });

  } catch (error) {
    console.error('Error fetching conversation messages:', error);
    if (error.kind === 'ObjectId') {
        return res.status(400).json({ message: 'Invalid conversation ID.' });
    }
    res.status(500).json({ message: 'Server error while fetching messages.', error: error.message });
  }
};

// @desc    –û—Ç–ø—Ä–∞–≤–∫–∞ —Å–æ–æ–±—â–µ–Ω–∏—è –≤ –¥–∏–∞–ª–æ–≥
// @route   POST /api/conversations/:recipientId/messages (–∏–ª–∏ –ø—Ä–æ—Å—Ç–æ /api/conversations/send)
// @access  Private
exports.sendMessage = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { text, media, youtubeUrl, sharedPost: sharedPostString } = req.body;
    const recipientId = req.params.recipientId;
    const senderId = req.user._id;

    // –ü–æ–ª—É—á–∞–µ–º –≥–ª–æ–±–∞–ª—å–Ω—ã–π –æ–±—ä–µ–∫—Ç io –∏–∑ req, –µ—Å–ª–∏ –æ–Ω –±—ã–ª —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω –≤ middleware
    const io = req.app.get('io');

    if (!recipientId) {
      await session.abortTransaction();
      session.endSession();
      return res.status(400).json({ message: 'Message recipient not specified.' });
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –¥–∏–∞–ª–æ–≥
    let conversation = await Conversation.findOne({
      participants: { $all: [senderId, recipientId] }
    }).session(session);

    // –ï—Å–ª–∏ –¥–∏–∞–ª–æ–≥–∞ –Ω–µ—Ç, —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤—ã–π
    if (!conversation) {
      conversation = new Conversation({
        participants: [senderId, recipientId],
        messages: []
      });
    }

    const newMessage = {
      sender: senderId,
      text: text ? text.trim() : '',
      createdAt: new Date() // –£—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ–º —Ç–µ–∫—É—â—É—é –¥–∞—Ç—É
    };

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –ø–µ—Ä–µ—Å–ª–∞–Ω–Ω–æ–≥–æ –ø–æ—Å—Ç–∞
    if (sharedPostString) {
      try {
        console.log('Received sharedPost JSON:', sharedPostString);
        const sharedPost = JSON.parse(sharedPostString);
        console.log('Parsed sharedPost:', JSON.stringify(sharedPost, null, 2));

        if (sharedPost && (sharedPost.id || sharedPost._id)) {
          // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ –ø–æ—Å—Ç –≤ –±–∞–∑–µ –¥–∞–Ω–Ω—ã—Ö
          const existingPost = await Post.findById(sharedPost.id || sharedPost._id);
          console.log('Existing post:', existingPost ? 'Found' : 'Not found');
          
          if (existingPost) {
            newMessage.sharedPost = {
              post: existingPost._id
            };
          } else {
            // –ï—Å–ª–∏ –ø–æ—Å—Ç –Ω–µ –Ω–∞–π–¥–µ–Ω, —Å–æ–∑–¥–∞–µ–º –≤—Ä–µ–º–µ–Ω–Ω—ã–π –ø–æ—Å—Ç
            const tempPost = new Post({
              author: senderId, // –¢–µ–∫—É—â–∏–π –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –∫–∞–∫ –∞–≤—Ç–æ—Ä
              caption: sharedPost.caption || '',
              image: sharedPost.image || sharedPost.imageUrl,
              imageUrl: sharedPost.imageUrl || sharedPost.image,
              mediaType: sharedPost.mediaType || 'image',
              videoUrl: sharedPost.videoUrl,
              youtubeData: sharedPost.youtubeData,
              createdAt: sharedPost.createdAt || new Date()
            });
            
            console.log('Creating temporary post:', JSON.stringify(tempPost, null, 2));
            
            const savedTempPost = await tempPost.save({ session });
            
            newMessage.sharedPost = {
              post: savedTempPost._id
            };
          }
        }
      } catch(e) {
        console.error("Failed to parse or process sharedPost JSON", e);
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ–ø–µ—Ä–∞—Ü–∏—é, –ø—Ä–æ—Å—Ç–æ –Ω–µ –¥–æ–±–∞–≤–ª—è–µ–º –ø–æ—Å—Ç
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ –º–µ–¥–∏–∞ —Ñ–∞–π–ª–æ–≤
    if (req.file) {
      // –í–∞–ª–∏–¥–∞—Ü–∏—è –∑–∞–≥—Ä—É–∂–µ–Ω–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
      try {
        const fileType = req.file.mimetype.startsWith('image/') ? 'image' : 'video';
        validateMediaFile(req.file, fileType);
        
        console.group('üì∏ –ú–µ–¥–∏–∞ –≤ —Å–æ–æ–±—â–µ–Ω–∏–∏');
        console.log('–¢–∏–ø —Ñ–∞–π–ª–∞:', fileType);
        console.log('–û—Ä–∏–≥–∏–Ω–∞–ª—å–Ω–æ–µ –∏–º—è:', req.file.originalname);
        console.log('–ü—É—Ç—å —Ñ–∞–π–ª–∞:', req.file.path);
        console.log('–ò–º—è —Ñ–∞–π–ª–∞:', req.file.filename);
        console.log('–†–∞–∑–º–µ—Ä —Ñ–∞–π–ª–∞:', req.file.size);
        console.log('MIME-—Ç–∏–ø:', req.file.mimetype);
        console.log('Google Drive Upload Result:', req.uploadResult);
        
        // –°–æ–∑–¥–∞–µ–º –æ—Ç–≤–µ—Ç –¥–ª—è –º–µ–¥–∏–∞ - –∏—Å–ø–æ–ª—å–∑—É–µ–º —Ç–æ–ª—å–∫–æ Google Drive
        const mediaResponse = {
          type: fileType,
          url: req.uploadResult.secure_url,
          filename: req.file.originalname,
          size: req.file.size,
          mimetype: req.file.mimetype
        };
        
        console.log('–ú–µ–¥–∏–∞ –æ—Ç–≤–µ—Ç:', JSON.stringify(mediaResponse, null, 2));
        console.groupEnd();
        
        newMessage.media = mediaResponse;
        newMessage.image = mediaResponse.url; // –î–ª—è –æ–±—Ä–∞—Ç–Ω–æ–π —Å–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç–∏
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –≤–∞–ª–∏–¥–∞—Ü–∏–∏ –º–µ–¥–∏–∞:', error);
        await session.abortTransaction();
        session.endSession();
        return res.status(400).json({ message: `Media validation failed: ${error.message}` });
      }
    } else if (media) {
      // –ú–µ–¥–∏–∞ –ø–µ—Ä–µ–¥–∞–Ω–æ –≤ JSON (–Ω–∞–ø—Ä–∏–º–µ—Ä, –¥–ª—è –ø—Ä—è–º—ã—Ö —Å—Å—ã–ª–æ–∫)
      console.group('üåê –ú–µ–¥–∏–∞ –∏–∑ JSON');
      console.log('–í—Ö–æ–¥—è—â–∏–µ –º–µ–¥–∏–∞:', media);
      console.log('–ü–æ–ª–Ω—ã–π –æ–±—ä–µ–∫—Ç –º–µ–¥–∏–∞:', JSON.stringify(media, null, 2));
      console.groupEnd();
      
      newMessage.media = media;
    } else if (youtubeUrl) {
      // –û–±—Ä–∞–±–æ—Ç–∫–∞ YouTube —Å—Å—ã–ª–∫–∏
      try {
        console.group('üì∫ YouTube –º–µ–¥–∏–∞');
        console.log('YouTube URL:', youtubeUrl);
        
        const youtubeData = processYouTubeUrl(youtubeUrl);
        console.log('–û–±—Ä–∞–±–æ—Ç–∞–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ YouTube:', youtubeData);
        
        newMessage.media = createMediaResponse(null, youtubeData);
        console.groupEnd();
      } catch (error) {
        console.error('‚ùå –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏ YouTube URL:', error);
        await session.abortTransaction();
        session.endSession();
        return res.status(400).json({ message: `YouTube URL validation failed: ${error.message}` });
      }
    }

    // –î–æ–±–∞–≤–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –≤ –¥–∏–∞–ª–æ–≥
    conversation.messages.push(newMessage);
    conversation.lastMessageAt = newMessage.createdAt;

    await conversation.save({ session });
    await session.commitTransaction();
    session.endSession();

    // –ù–∞—Å–µ–ª—è–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ—Å–ª–µ–¥–Ω–µ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –¥–ª—è –Ω–µ–º–µ–¥–ª–µ–Ω–Ω–æ–≥–æ –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –Ω–∞ –∫–ª–∏–µ–Ω—Ç–µ
    const lastMessageIndex = conversation.messages.length - 1;
    await conversation.populate([
      {
        path: `messages.${lastMessageIndex}.sender`,
        select: 'username avatar'
      },
      {
        path: `messages.${lastMessageIndex}.sharedPost.post`,
        model: 'Post',
        populate: [
          {
            path: 'author',
            select: 'username avatar'
          },
          {
            path: 'comments',
            populate: {
              path: 'user',
              model: 'User',
              select: 'username avatar'
            }
          }
        ]
      }
    ]);
    const sentMessage = conversation.messages[lastMessageIndex];

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—é —á–µ—Ä–µ–∑ Socket.IO, –µ—Å–ª–∏ io –¥–æ—Å—Ç—É–ø–µ–Ω
    if (io) {
      io.to(recipientId).emit('newMessage', {
        conversationId: conversation._id,
        message: sentMessage,
        sender: req.user
      });
    }

    // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—é
    try {
      // –ü–æ–ª—É—á–∞–µ–º –¥–∞–Ω–Ω—ã–µ –ø–æ–ª—É—á–∞—Ç–µ–ª—è
      const recipient = await User.findById(recipientId).select('username email avatar');
      
      if (recipient && recipient.email) {
        // –ü–æ–¥–≥–æ—Ç–∞–≤–ª–∏–≤–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–ª—è email
        const messageData = {
          text: sentMessage.text,
          media: sentMessage.media,
          sharedPost: sentMessage.sharedPost ? {
            image: sentMessage.sharedPost.post?.image || sentMessage.sharedPost.post?.imageUrl,
            caption: sentMessage.sharedPost.post?.caption,
            author: sentMessage.sharedPost.post?.author?.username || 'Unknown'
          } : null
        };

        const senderData = {
          username: req.user.username,
          avatar: req.user.avatar
        };

        // –û—Ç–ø—Ä–∞–≤–ª—è–µ–º email —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ (–∞—Å–∏–Ω—Ö—Ä–æ–Ω–Ω–æ, –Ω–µ –±–ª–æ–∫–∏—Ä—É–µ–º –æ—Ç–≤–µ—Ç)
        sendNewMessageNotification(recipient.email, messageData, senderData, recipient)
          .then(() => {
            console.log(`üìß Email notification sent to ${recipient.email} for message from ${senderData.username}`);
          })
          .catch((error) => {
            console.error(`‚ùå Failed to send email notification to ${recipient.email}:`, error);
          });
      }
    } catch (emailError) {
      console.error('‚ùå Error preparing email notification:', emailError);
      // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –æ—Å–Ω–æ–≤–Ω—É—é –æ–ø–µ—Ä–∞—Ü–∏—é –∏–∑-–∑–∞ –æ—à–∏–±–∫–∏ email
    }

    res.status(201).json({
      message: 'Message sent successfully',
      sentMessage
    });

  } catch (error) {
    console.error('Error sending message:', error);
    await session.abortTransaction();
    session.endSession();
    res.status(500).json({ message: 'Server error while sending message.', error: error.message });
  }
};

// @desc    –£–¥–∞–ª–µ–Ω–∏–µ —Å–æ–æ–±—â–µ–Ω–∏—è
// @route   DELETE /api/conversations/messages/:conversationId/:messageId
// @access  Private
exports.deleteMessage = async (req, res) => {
  const session = await mongoose.startSession();
  session.startTransaction();

  try {
    const { conversationId, messageId } = req.params;
    const userId = req.user.id;

    console.log('[DELETE_MESSAGE_DEBUG] Attempt to delete message:', {
      conversationId,
      messageId,
      currentUserId: userId
    });

    const conversation = await Conversation.findById(conversationId)
      .populate({
        path: 'messages.sender',
        select: '_id username'
      })
      .session(session);

    if (!conversation) {
      console.error('[DELETE_MESSAGE_DEBUG] Conversation not found');
      await session.abortTransaction();
      session.endSession();
      return res.status(404).json({ message: 'Conversation not found.' });
    }

    const messageToDelete = conversation.messages.id(messageId);

    if (!messageToDelete) {
      console.error('[DELETE_MESSAGE_DEBUG] Message not found');
      await session.abortTransaction();
      session.endSession();
      return res.status(404).json({ message: 'Message not found.' });
    }

    console.log('[DELETE_MESSAGE_DEBUG] Message details:', {
      senderId: messageToDelete.sender._id.toString(),
      senderUsername: messageToDelete.sender.username,
      currentUserId: userId,
      media: messageToDelete.media
    });

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–∞–≤–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –Ω–∞ —É–¥–∞–ª–µ–Ω–∏–µ
    if (messageToDelete.sender._id.toString() !== userId) {
      console.warn('[DELETE_MESSAGE_DEBUG] User not authorized to delete this message');
      await session.abortTransaction();
      session.endSession();
      return res.status(403).json({ message: 'Not authorized to delete this message.' });
    }

    // –£–¥–∞–ª–µ–Ω–∏–µ —Ñ–∞–π–ª–∞ —Å Google Drive, –µ—Å–ª–∏ –µ—Å—Ç—å –º–µ–¥–∏–∞
    if (messageToDelete.media && messageToDelete.media.url) {
      try {
        const googleDrive = require('../config/googleDrive');
        const url = messageToDelete.media.url;
        
        console.log('[DELETE_MESSAGE_DEBUG] Media URL:', url);
        
        if (url.includes('drive.google.com')) {
          const fileId = url.match(/\/d\/([^/]+)/)?.[1] || url.split('id=')[1] || url.split('/').pop();
          
          console.log('[DELETE_MESSAGE_DEBUG] Extracted File ID:', fileId);
          
          if (fileId) {
            await googleDrive.deleteFile(fileId);
            console.log(`[DELETE_MESSAGE_DEBUG] ‚úÖ Successfully deleted media file: ${fileId}`);
          }
        }
      } catch (driveError) {
        console.error('[DELETE_MESSAGE_DEBUG] Error deleting file from Google Drive:', driveError);
        // –ù–µ –ø—Ä–µ—Ä—ã–≤–∞–µ–º –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ, –µ—Å–ª–∏ –Ω–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å —Ñ–∞–π–ª
      }
    }

    // –£–¥–∞–ª—è–µ–º —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –º–∞—Å—Å–∏–≤–∞ —Å–æ–æ–±—â–µ–Ω–∏–π
    conversation.messages.pull(messageId);

    // –û–±–Ω–æ–≤–ª—è–µ–º lastMessageAt, –µ—Å–ª–∏ —ç—Ç–æ –±—ã–ª–æ –ø–æ—Å–ª–µ–¥–Ω–µ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ
    if (conversation.messages.length > 0) {
      conversation.lastMessageAt = conversation.messages[conversation.messages.length - 1].createdAt;
    } else {
      conversation.lastMessageAt = null;
    }

    await conversation.save({ session });
    await session.commitTransaction();
    session.endSession();

    console.log('[DELETE_MESSAGE_DEBUG] Message deleted successfully');

    res.status(200).json({ 
      message: 'Message deleted successfully',
      deletedMedia: messageToDelete.media ? messageToDelete.media.url : null
    });

  } catch (error) {
    console.error('[DELETE_MESSAGE_DEBUG] Error deleting message:', error);
    await session.abortTransaction();
    session.endSession();
    res.status(500).json({ 
      message: 'Server error while deleting message.', 
      error: error.message 
    });
  }
};